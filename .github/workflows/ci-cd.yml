name: PayMyBuddy Advanced CI/CD Pipeline

on:
  push:
    branches: [ dev, main ]
  pull_request:
    branches: [ main ]

env:
  # Configuration de base
  DOCKER_REPO: ${{ secrets.DOCKERHUB_USERNAME }}/paymybuddy
  DOCKER_IMAGE_TAG: ${{ github.sha }}
  MYSQL_DATABASE: paymybuddy_test

jobs:
  # Construction de l'image Docker et exécution des tests
  build-and-test:
    name: Build & Test in Docker
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # Configuration de Docker Buildx pour des builds multi-architectures
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Configuration des accès Docker Hub pour les étapes suivantes
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Création d'un réseau Docker pour les tests
      - name: Create Docker network
        run: docker network create paymybuddy-test-network

      # Démarrage d'un conteneur MySQL pour les tests
      - name: Start MySQL Container
        run: |
          docker run -d --name mysql-test \
            --network paymybuddy-test-network \
            -e MYSQL_ROOT_PASSWORD=${{ secrets.DB_PASSWORD }} \
            -e MYSQL_DATABASE=${MYSQL_DATABASE} \
            mysql:8.0 \
            --character-set-server=utf8mb4 \
            --collation-server=utf8mb4_unicode_ci
          
          # Attente que MySQL soit prêt avant de continuer
          echo "Waiting for MySQL to be ready..."
          timeout=60
          until docker exec mysql-test mysqladmin ping -h localhost -u root -p${{ secrets.DB_PASSWORD }} --silent || [ $timeout -le 0 ]; do
            sleep 1
            ((timeout--))
          done

      # Construction de l'image de test avec Maven et JDK préinstallés
      - name: Build test image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.test  # Dockerfile spécifique pour les tests
          push: false
          load: true
          tags: paymybuddy-test:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Exécution des tests unitaires dans le conteneur
      - name: Run Unit Tests
        run: |
          docker run --rm \
            --network paymybuddy-test-network \
            -e SPRING_DATASOURCE_URL=jdbc:mysql://mysql-test:3306/${MYSQL_DATABASE} \
            -e SPRING_DATASOURCE_USERNAME=root \
            -e SPRING_DATASOURCE_PASSWORD=${{ secrets.DB_PASSWORD }} \
            -v ${{ github.workspace }}/target:/app/target \
            paymybuddy-test:latest \
            mvn test

      # Exécution des tests d'intégration dans le conteneur
      - name: Run Integration Tests
        run: |
          docker run --rm \
            --network paymybuddy-test-network \
            -e SPRING_DATASOURCE_URL=jdbc:mysql://mysql-test:3306/${MYSQL_DATABASE} \
            -e SPRING_DATASOURCE_USERNAME=root \
            -e SPRING_DATASOURCE_PASSWORD=${{ secrets.DB_PASSWORD }} \
            -v ${{ github.workspace }}/target:/app/target \
            paymybuddy-test:latest \
            mvn failsafe:integration-test

      # Génération des rapports de couverture JaCoCo
      - name: Generate JaCoCo Coverage Report
        run: |
          docker run --rm \
            -v ${{ github.workspace }}/target:/app/target \
            paymybuddy-test:latest \
            mvn jacoco:report

      # Génération de la documentation JavaDoc
      - name: Generate JavaDocs
        run: |
          docker run --rm \
            -v ${{ github.workspace }}/target:/app/target \
            paymybuddy-test:latest \
            mvn javadoc:javadoc

      # Déplacement des JavaDocs vers le répertoire site
      - name: Move JavaDocs to target/site
        run: |
          mkdir -p target/site
          mv target/reports/apidocs target/site/apidocs || true

  # Analyse de sécurité de l'image Docker
  security-scan:
    name: Docker Image Security Scan
    runs-on: ubuntu-latest
    needs: build-and-test

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # Construction de l'image de production pour le scan
      - name: Build Production Image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: false
          load: true
          tags: ${{ env.DOCKER_REPO }}:${{ env.DOCKER_IMAGE_TAG }}

      # Scan de l'image Docker avec Trivy pour détecter les vulnérabilités
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.DOCKER_REPO }}:${{ env.DOCKER_IMAGE_TAG }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      # Publication des résultats de sécurité dans GitHub Security
      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  # Publication de l'image Docker et déploiement des rapports
  publish-and-deploy:
    name: Publish & Deploy
    runs-on: ubuntu-latest
    needs: [build-and-test, security-scan]
    if: success() && github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev')

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # Configuration de Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Configuration des accès Docker Hub
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Détermination du tag de l'image en fonction de la branche
      - name: Set Image Tag
        id: set-tag
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "TAG=latest" >> $GITHUB_OUTPUT
          else
            echo "TAG=dev" >> $GITHUB_OUTPUT
          fi

      # Construction et publication de l'image vers Docker Hub
      # Construction multi-architecture pour compatibilité x86_64 et ARM64
      - name: Build and Push Production Image
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ env.DOCKER_REPO }}:${{ steps.set-tag.outputs.TAG }}
            ${{ env.DOCKER_REPO }}:${{ env.DOCKER_IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Téléchargement des rapports générés précédemment
      - name: Download reports
        uses: actions/download-artifact@v4
        with:
          name: jacoco-report
          path: ./target/site/jacoco

      - name: Download JavaDocs
        uses: actions/download-artifact@v4
        with:
          name: javadocs
          path: ./target/site/apidocs

      # Déploiement des rapports vers GitHub Pages
      - name: Deploy reports to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./target/site

      # Notification de succès du déploiement (exemple Slack)
      - name: Slack Notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: always()